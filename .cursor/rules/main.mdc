---
description: 
globs: **/*.vue,**/*.ts
alwaysApply: false
---
# Shephard Project Guidelines

You are an expert in Vue.js 3, TypeScript, Quasar Framework, Pinia, Supabase, and modern frontend development. The Shephard project is a smart expenses wallet application using the Quasar framework with Vue 3 and TypeScript.

## Code Style and Structure

- Use the Vue 3 Composition API with `<script setup lang="ts">` in all components.
- Prefer named exports and functional programming patterns; avoid classes.
- Use TypeScript for all code with explicit typing; prefer `type` over `interface`.
- Organize files systematically: each file should have a single responsibility.
- Follow a clean component structure with clear separation of template, script, and styles.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Don't write unneccessary commments, especially if variable or function name is explicit.

## Component Guidelines

- Use Quasar components (prefixed with `q-`) for UI elements.
- Implement responsive design with Quasar's flex utilities and responsive classes.
- Use composables for reusable logic across components.
- Keep components small and focused on a single responsibility.
- Use scoped CSS for component-specific styles.
- Always use computed properties instead of calling functions directly in templates for better reactivity and performance.

## Navigation and Links

- Use Quasar's built-in routing components instead of manual event handlers for navigation.
- Prefer `q-btn` with the `to` prop over manual `@click="$router.push()"` for navigation links.
- For main navigation elements, use `q-btn` with appropriate styling (e.g., `flat`, `no-caps`).
- When styling navigation buttons, use Quasar's text utility classes like `text-white` and `text-h6`.
- Avoid using custom router-link components when Quasar provides equivalent functionality.

## Template Formatting

- For all tags (both Quasar components and HTML elements) with multiple attributes, place each attribute on a new line with consistent indentation.
- Always format multi-line tag content with proper spacing:
  ```vue
  <any-tag
    attribute1="value"
    attribute2="value"
  >
    Content goes here
  </any-tag>
  ```
- Never use self-closing syntax for content-containing elements (e.g., avoid `>Content</tag>`).
- Keep closing tags aligned with opening tags when the content spans multiple lines.
- Apply the same formatting rules to all components, not just specific ones.

## State Management

- Use Pinia for state management with the setup-style store pattern.
- Create separate stores for different domains (auth, user data, etc.).
- Use computed properties for derived state.
- Use refs for reactive state within components and stores.

## Authentication

- The app uses Supabase for authentication with both Magic Link (OTP) and Google Sign-In.
- Security features like CSRF protection and nonce validation are implemented.
- Use the auth store for managing authentication state and operations.

## Routing

- The app uses Vue Router with lazy-loaded components.
- Auth guards are implemented to protect routes.
- Meta fields are used to specify route requirements.

## API Integration

- Supabase client is used for backend integration.
- Typed database schema is implemented.
- Environment variables are used for configuration.

## Services Architecture

- Use a domain-driven service layer pattern with files named `[domain].service.ts`.
- Export all services through a barrel file (index.ts) for easy importing.
- Service functions should be standalone and focused on a single responsibility.
- Implement centralized error handling with context-aware error messages.
- Services should abstract database interactions from UI components.
- Services should contain business logic for data processing and validation.
- Type all service function parameters and return values explicitly.
- Use descriptive JSDoc comments for service function documentation.

## Error Handling

- Implement proper error handling with try/catch blocks.
- Provide user-friendly error messages.
- Log errors to console for debugging.

## Performance Considerations

- Lazy load routes and components.
- Use proper reactive primitives to avoid unnecessary re-renders.
- Implement proper cleanup in component lifecycle hooks.

## Testing

- The project uses Vitest for unit testing.
- Write tests for critical functionality, especially authentication flows.

## Styling and Layout

- Use Quasar's built-in utility classes for spacing, margin, and padding instead of custom CSS whenever possible
- Prefer `q-pa-*` and `q-ma-*` classes over custom styling for consistent spacing
- Use Quasar's grid system with responsive classes (`col-*`, `col-sm-*`, etc.) for adaptable layouts
- For background styling, use Quasar's color classes (`bg-*`) and helper classes (`rounded-borders`, etc.)

## Component Design

- Use `withDefaults()` with TypeScript interfaces for component props instead of computed properties for defaults
- Include proper responsive breakpoints in all user-facing layouts
- Use Quasar's form components with consistent styling and spacing

## Code Structure

- Group related functionality in clear sections with descriptive comments
- When displaying user information, use proper null handling and optional chaining
- For repeated UI patterns, create dedicated components rather than duplicating code
- Follow a consistent pattern for data presentation: labels as captions, values as regular text
