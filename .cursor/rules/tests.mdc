---
description: 
globs: **/*.test.ts
alwaysApply: false
---
# Test Guidelines

Before writing tests, create a plan for what exactly to test and check it with me.

## Framework & Libraries

- Use `Vitest` as the test runner.
- Use `@vue/test-utils` v2+ for Vue component testing.
- Run tests using `npm run test:unit:ci` command

## File Structure

- Use `.test.ts` extension.
- Co-locate test files with the files they test.

## Test Organization

- For Vue components, **do not** use a root `describe` block.
- For other modules, use a root `describe` block if helpful.
- Group related tests under `describe` blocks with clear descriptions.
- Use `beforeEach` for setup and `afterEach` for cleanup, only when needed.
- Use descriptive test names that explain the expected behavior.
- Test mount/unmount effects if relevant.

## Best Practices

- Test features the way users use them.
- Write minimal, focused, readable tests that verify one behavior at a time.
- Avoid unnecessary test data—use the smallest data structure needed.
- Avoid writing tests that offer no real safety or insight.

## Mocking

- Only mock what is necessary for the test to run.
- Avoid unnecessary stubs like `$patch: vi.fn()` or `$reset: vi.fn()`.
- Before mocking with `vi.mock()`, check if the module is already mocked in a local `__mocks__` folder.
- Prefer extracting individual mock functions for clarity and type safety.

### Example:
```ts
const mockRouterPush = vi.fn()
const mockRouter = { push: mockRouterPush }
```

## Comments

- **You don’t need to write comments.**
  Avoid obvious comments like `// Mock a function`.

## Component Testing

- Use `createTestingPinia` to mock store behavior and isolate logic.
- Add a dedicated `render` function at the top of the test file.
  - Include common props, providers, and stubs.
  - Type component props using `ComponentProps<typeof ComponentName>`.
- Use `global.provide` and `global.stubs` for context and child components.
- Use real child components only when their logic matters to the test.

## Quasar Component Testing

- Use `installQuasarPlugin()` at the start of the test file.
- Stub Quasar plugins (Notify, Dialog, etc.).
- Test layout components (`<q-layout>`, `<q-page>`) in isolation.
- Avoid testing third-party behavior unless you explicitly wrap it.

### Example:
```ts
installQuasarPlugin()

describe('layout example', () => {
  it('should mount component properly', () => {
    const wrapper = mount(LayoutComponent)
    expect(wrapper.exists()).toBe(true)
  })
})
```

## Pinia Store Testing

- Initialize stores using `createTestingPinia({ createSpy: vi.fn })` in `beforeEach`.
- Access stores via their hooks (`useStore()`).
- Modify store state using `ref()` and `// @ts-expect-error` for type bypassing.

### Example:
```ts
// @ts-expect-error - Testing Pinia
storeInstance.someProperty = ref(mockValue)
```

- Use `expect().toHaveBeenCalledWith()` to verify method calls.
- Use `stubActions: false` in `createTestingPinia()` when real actions are needed.
- For testing the store itself, use `createPinia()` directly.

## TypeScript Integration

- Never use `any`. Use `unknown` for conversions:
  ```ts
  mock as unknown as TargetType
  ```
- Use `// @ts-expect-error` with a reason when needed.
- Use interface merging to extend global types:
  ```ts
  declare global {
    interface Window {
      customProperty?: SomeType
    }
  }
  ```

## Test Lifecycle & Cleanup

- Use `beforeEach` for resetting test state.
- Use `afterEach` only if cleanup can't happen in `beforeEach`.
- Avoid duplicate cleanup in both hooks.
- Clean up global state (e.g., `window`) in setup.

## Import Management

- Only import what’s used.
- Remove unused lifecycle hooks like `beforeAll`, `afterEach`, etc.
- Prefer specific imports over entire libraries.

## Test Data Creation

- Create realistic, minimal test data reflecting app patterns.
- Avoid excessive or irrelevant properties.

## Vue Composable Testing

- Test both initial state and reactivity.
- Test meaningful branches of logic.
- Mock external dependencies like APIs and browser features.
- Ensure proper cleanup and type safety.

### Quasar Mocks
- Include `Quasar` export when mocking:
  ```ts
  vi.mock('quasar', () => ({
    Dark: { set: vi.fn() },
    Quasar: {}, // required
  }))
  ```

### Reactivity Example
```ts
it('should react to state changes', async () => {
  const someRef = ref(false)
  expect(something).toBe(initialValue)

  vi.clearAllMocks()
  someRef.value = true
  await nextTick()
  expect(something).toBe(newValue)
})
```

## Browser API Mocks

- Create reusable helpers for mocking browser APIs (like `matchMedia`).

### Example:
```ts
const mockMatchMedia = () => {
  const mockMediaQueryList = {
    matches: false,
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
  }

  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: vi.fn().mockImplementation(() => mockMediaQueryList),
  })

  return mockMediaQueryList
}
```

## Type-Safe Event Testing

- Use optional chaining and guards:
  ```ts
  const cb = mock.addEventListener.mock.calls[0]?.[1]
  expect(cb).toBeDefined()
  if (cb) {
    cb({ someData: true } as SomeEventType)
    expect(result).toBe(expected)
  }
  ```