---
description: Project architecture patterns and data flow guidelines
globs:
alwaysApply: true
---

# Architecture Patterns

## API Layer Architecture

- Use a dedicated API layer in `src/api/` to abstract all external data operations (Supabase, third-party APIs).
- Create domain-specific API files named `[domain].ts` (e.g., `auth.ts`, `user.ts`, `expenses.ts`).
- Export all API functions through a barrel file (`src/api/index.ts`) for centralized imports.
- API functions should be pure data fetchers with single responsibility.
- API functions must throw errors directly rather than returning error objects.
- API functions should return data directly, not wrapped in `{data, error}` objects.

## Store-API Integration

- Stores should import and use API functions instead of making direct Supabase calls.
- Only exception: `supabase.auth.onAuthStateChange()` subscriptions should remain in stores for reactive state management.
- Stores are responsible for catching API errors using the `useError` composable.
- Stores should return data directly to components, not `{data, error}` objects.
- Error handling is centralized in stores; components should not check for errors.
- State management logic (setting loading states, reactive updates) belongs in stores.

### Store Function Pattern:

```typescript
async function loadUser(userId: string) {
  try {
    const user = await getUserById(userId)
    userState.value = user
    return user
  } catch (error) {
    handleError('USER.LOAD_FAILED', error, { userId })
  }
}

// For void functions:
async function saveData() {
  try {
    await saveToDatabase()
    // Update state...
  } catch (error) {
    handleError('DATA.SAVE_FAILED', error)
    // No return needed for void functions
  }
}
```

## Error Handling Architecture

- Always use the `useError` composable to handle errors consistently throughout the application.
- Follow a clear error handling hierarchy:
  1. **API Layer**: API functions should throw errors directly without handling them.
  2. **Stores**: Catch errors from API functions using the `useError` composable's `handleError` function. Stores are responsible for error management.
  3. **Components**: Do not implement error handling logic. Components should call store methods and let the stores handle any errors.
- Use the `handleError` method with predefined error keys from the error configuration system for consistent, user-friendly messaging.
- Use descriptive, user-friendly error messages with context (e.g., "Failed to load user preferences" rather than "API error").
- In stores, import and use the `useError` composable with the `handleError` method
- Pass relevant context information (userId, component, action, etc.) to provide better debugging information
- Keep UI components clean by avoiding direct error handling or error state management.
- For composables, let errors propagate to calling stores rather than handling them internally.
- Maintain a centralized error message system in `src/config/error-messages.ts` for consistent messaging.
- In catch blocks after calling error handling methods, don't use return statement no matter the function.

## State Management

- Use Pinia for state management with the setup-style store pattern.
- Create separate stores for different domains (auth, user data, etc.).
- Use computed properties for derived state.
- Use refs for reactive state within components and stores.

## API-Store-Component Pattern

- **API Layer** (`src/api/`): Pure data fetchers that throw errors and return data directly
- **Store Layer** (`src/stores/`): State management, error handling, business logic coordination
- **Component Layer**: UI rendering and user interaction, delegates to stores for data operations
- API files should define and export data types used in their operations
- Store files should import types from API files rather than redefining them
- When a store needs to extend an API type, use type composition rather than duplication
- Stores should handle type conversions between the UI layer and API layer when necessary
- Maintain consistent file organization: each domain should have corresponding API and store files

## Authentication Architecture

- The app uses Supabase for authentication with both Magic Link (OTP) and Google Sign-In.
- Security features like CSRF protection and nonce validation are implemented.
- Use the auth store for managing authentication state and operations.

## Routing Architecture

- The app uses Vue Router with lazy-loaded components.
- Auth guards are implemented to protect routes.
- Meta fields are used to specify route requirements.
