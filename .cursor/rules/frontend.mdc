---
description: Vue.js, Quasar Framework, UI development, and performance guidelines
globs:
alwaysApply: true
---

# Frontend Development Guidelines

## Vue.js Specific

- Always use the Vue Composition API script setup style.
- Do not use `props.{key}` in component templates. Use `{key}` directly. This is how Vue works
- When adding smaller components to the template, remember to import them
- Composable functions should only be called directly in `<script setup>` blocks, or from within other composable functions.
- Don't pass functions as props to child components. Emit events from child components and handle them at parent level.

## Template Formatting

- For all tags (both Quasar components and HTML elements) with multiple attributes, place each attribute on a new line with consistent indentation.
- Always format multi-line tag content with proper spacing:
  ```vue
  <any-tag attribute1="value" attribute2="value">
    Content goes here
  </any-tag>
  ```
- Never use self-closing syntax for content-containing elements (e.g., avoid `>Content</tag>`).
- Keep closing tags aligned with opening tags when the content spans multiple lines.
- Apply the same formatting rules to all components, not just specific ones.

## Navigation and Links

- Use Quasar's built-in routing components instead of manual event handlers for navigation.
- Prefer `q-btn` with the `to` prop over manual `@click="$router.push()"` for navigation links.
- For main navigation elements, use `q-btn` with appropriate styling (e.g., `flat`, `no-caps`).
- When styling navigation buttons, use Quasar's text utility classes like `text-white` and `text-h6`.
- Avoid using custom router-link components when Quasar provides equivalent functionality.

## Styling and Layout

- Use Quasar's built-in utility classes for spacing, margin, and padding instead of custom CSS whenever possible
- Prefer `q-pa-*` and `q-ma-*` classes over custom styling for consistent spacing
- Use Quasar's grid system with responsive classes (`col-*`, `col-sm-*`, etc.) for adaptable layouts
- For background styling, use Quasar's color classes (`bg-*`) and helper classes (`rounded-borders`, etc.)

## Component Design

- Use `withDefaults()` with TypeScript interfaces for component props instead of computed properties for defaults
- Include proper responsive breakpoints in all user-facing layouts
- Use Quasar's form components with consistent styling and spacing
- Avoid logic in templates. Encourage extracting even small logic to the `<script setup>` block

## Code Structure

- Group related functionality in clear sections with descriptive comments
- When displaying user information, use proper null handling and optional chaining
- For repeated UI patterns, create dedicated components rather than duplicating code
- Follow a consistent pattern for data presentation: labels as captions, values as regular text

## Delightful User Experience

- Implement optimistic UI where possible
- Ensure that all interactive elements can be accessed and controlled with a keyboard
- Minimise layout shift
- Implement client-side validation for forms with clear error messages
- Inform the user when an API request fails
- Show loading states for asynchronous operation

## Quasar-Specific Guidelines

- Leverage Quasar components, plugins and helpers over custom implementation

# Performance Guidelines

## Core Performance Principles

- Lazy load routes and components to reduce initial bundle size
- Use proper reactive primitives to avoid unnecessary re-renders
- Implement proper cleanup in component lifecycle hooks
- Minimize layout shift through proper component design
- Optimize for mobile-first performance given PWA nature

## Vue.js Performance

- Use `shallowRef` and `shallowReactive` when deep reactivity is not needed
- Implement proper key attributes for v-for loops to optimize virtual DOM diffing
- Use `v-once` directive for static content that won't change
- Avoid creating objects or arrays directly in templates
- Use computed properties instead of methods for expensive calculations
- Implement proper component lazy loading with dynamic imports

## Bundle Optimization

- Use dynamic imports for route-based code splitting
- Implement proper tree shaking by using named imports
- Optimize images with appropriate formats (WebP, AVIF when supported)
- Use Vite's bundle analysis tools to identify large dependencies
- Implement proper preloading for critical resources
- Minimize CSS bundle size by purging unused styles

## API and Data Performance

- Implement proper caching strategies for API responses
- Use pagination for large data sets
- Implement optimistic UI updates to improve perceived performance
- Batch API requests when possible to reduce network overhead
- Use Supabase's real-time features efficiently to avoid polling
- Implement proper error handling that doesn't block user interactions

## PWA Performance

- Implement proper service worker caching strategies
- Use app shell pattern for instant loading
- Implement background sync for offline functionality
- Cache critical resources for offline usage
- Use proper manifest configuration for fast app startup
- Implement proper update strategies for service workers

## Memory Management

- Remove event listeners in component cleanup
- Cancel ongoing API requests when components unmount
- Use WeakMap and WeakSet for temporary object references
- Avoid memory leaks in global stores by proper cleanup
- Implement proper disposal of reactive watchers and subscriptions

## Mobile Performance

- Optimize touch interactions and gesture handling
- Use proper viewport settings for mobile rendering
- Implement efficient scrolling with virtual scrolling for large lists
- Optimize images for different screen densities
- Use hardware acceleration wisely to avoid battery drain
- Implement proper loading states for slow network connections

## Monitoring and Metrics

- Use proper performance monitoring tools to track Core Web Vitals
- Monitor bundle size changes in CI/CD pipeline
- Track API response times and error rates
- Implement user experience metrics collection
- Monitor memory usage and potential leaks
- Track offline functionality usage and effectiveness

## Quasar Performance

- Leverage Quasar's built-in lazy loading components
- Use Quasar's virtual scrolling for large datasets
- Optimize Quasar theme usage to reduce CSS overhead
- Use Quasar's icon optimization features
- Implement proper Quasar plugin loading to reduce bundle size
- `$q` is available in the `<template>` automatically, there is no need to import `useQuasar`
